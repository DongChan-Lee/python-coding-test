# 문제 : 손님이 요청한 떡의 총 길이가 M일 때, 적어도 M만큼의 떡을 얻기 위해 절단기에 설정할 수 있는 "높이(H)의 최댓값" 구하기
#       절단기에 높이(H)를 지정하면 떡을 한 번에 절단하여 높이가 H보다 긴 떡은 H 위의 부분이 잘리고, 낮은 떡은 잘리지 않음
#       손님은 H 위의 부분으로 잘린 떡을 가져갈 수 있음
# 조건 : 1 <= N(떡의 개수) <= 1,000,000 / 1 <= M(요청한 떡의 길이) <= 2,000,000,000 / H(절단기 높이)는 10억 이하의 양의 정수


##### 내 풀이 : 절단기 높이(h)의 초기값을 설정하고, 이진탐색 bisect_right() 함수를 이용하여 h보다 긴 떡들만 남기고, 손님이 요청한 길이(M)와 h로 잘린 값들을 비교하며 h의 최댓값 탐색
#             But, '이진탐색 함수'를 사용했지만, 풀이 접근법은 이진탐색으로 범위를 좁혀나가는 게 아닌, 순차탐색으로 풀어서 시간 초과를 받을 수도 있음
# < 아이디어 >
# 절단기 높이(h)의 초기값을 (전체 떡의 길이 중 가장 큰 값 - 손님이 요청한 총 길이(M)) 로 설정하면
# 전체 떡 각각에서 h만큼 뺀 값들의 합이 손님이 요청한 총 길이(M)보다 크거나 같을 수밖에 없으므로
# h의 최대값을 찾기 위해 h를 1씩 늘려가며 확인
# 만약, 전체 떡 각각에서 h만큼 뺀 값들의 합이 손님이 요청한 총 길이(M)보다 작아지는 지점이 오면 h - 1 출력

# < 예시 >
# h = 13(초기값: 19 - 6)일 때,
# big_lst = [15, 17, 19] -> sum([2, 4, 6]) = 12

# h = 14일 때,
# big_lst = [15, 17, 19] -> sum([1, 3, 5]) = 9

# h = 15일 때,
# big_lst = [17, 19] -> sum([2, 4]) = 6

import sys
from bisect import bisect_right

n, m = map(int, input().split())
total = list(map(int, sys.stdin.readline().rstrip().split()))
total.sort()

h = total[-1] - m      # h의 초기값 설정 (전체 떡의 길이 중 가장 큰 값 - 손님이 요청한 총 길이)
def solution(array, target):
    while True:
        index = bisect_right(array, target)        # 전체 떡 중 target(h)보다 큰 값의 index 찾기
        big_lst = array[index:]                    # target(h)보다 큰 값만 남긴 list
        sum_ = sum([i - target for i in big_lst])  # big_lst에서 target(h)만큼 다 빼준 걸 sum
        if sum_ == m:
            return target
        elif sum_ < m:
            return target - 1
        else:
            target += 1

print(solution(total, h))


##### 답안 예시
# 문제 유형 설명 : 전형적인 이진 탐색 문제이자, 파라메트릭 서치(Parametric Search; 최적화 문제를 결정 문제(Yes or No)로 바꾸어 해결하는 기법) 유형의 문제
#              '원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제'에 주로 Parametric Search를 사용함 -> "이진 탐색"으로 해결
#               (ex) 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제(Parametric Search) -> "이진 탐색"을 이용하여 범위를 좁혀나가며 해결
# 풀이 아이디어 : 적절한 높이를 찾을 때까지 절단기의 높이 H를 반복해서 조정하는 것
#              '현재 이 높이로 자르면 조건을 만족할 수 있는가?'를 확인한 뒤 조건의 만족 여부(Yes or No)에 따라 탐색 범위를 좁혀서 해결
#              범위를 좁힐 때는 이진 탐색의 원리를 이용하여 '절반씩' 탐색 범위를 좁혀 나감
# 문제 분석 : 절단기의 높이(탐색 범위)는 1부터 10억까지의 정수 중 하나인데, 이처럼 큰 수(ex. 10억)를 보면 가장 먼저 "이진 탐색"을 떠올려야 함
#           '10억'까지의 탐색 범위를 이진 탐색으로 찾는다면, 대략 '31번' 만에 경우의 수를 모두 고려할 수 있음
#           떡의 개수 N이 최대 100만 개이므로 모든 경우를 체크하는 경우 대략 최대 3,000만 번 정도의 연산으로 풀 수 있음 (31 x 100만 = 3,100만)
#           문제의 시간 제한은 2초이므로 최악의 경우 3,000만 번 정도의 연산이 필요하다면 아슬아슬하게 시간 초과를 받지 않고 정답 판정을 받을 것
# (참고) 이 문제와 같은 Parametric Search 문제 유형은 이진 탐색을 재귀적으로 구현하지 않고 "반복문"을 이용해 구현하면 더 간결하게 풀 수 있음!

n, m = map(int, input().split(' '))       # 떡의 개수(N)와 요청한 떡의 길이(M)를 입력받기
array = list(map(int, input().split()))   # 각 떡의 개별 높이 정보 입력받기

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행 (반복문)
result = 0
while (start <= end):
    total = 0
    mid = (start + end) // 2
    
    for x in array:
        if x > mid:
            total += x - mid    # 잘랐을 때의 떡의 양(total) 계산
    
    # 떡의 양이 부족한 경우, 절단기 높이를 더 낮춰서 자르기 (왼쪽 부분 탐색)
    if total < m:
        end = mid - 1
    # 떡의 양이 충분한 경우, 절단기 높이를 더 높여서 자르기 (오른쪽 부분 탐색)
    else:
        result = mid            # 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록
        start = mid + 1

print(result)


# Test Case.
# < input >
# 4 6            # N, M
# 19 15 10 17    # 떡의 개별 높이

# output : 15    # 높이(H)의 최댓값