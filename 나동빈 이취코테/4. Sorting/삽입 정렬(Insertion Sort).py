# 삽입 정렬(Insertion Sort) : 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 과정을 (N - 1)번 반복하여 정렬
# 특징 : 1. 특정 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정
#          -> 따라서 삽입 정렬은 2번째 데이터부터 시작 (1번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문)
#       2. 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적임
#          -> (cf) 선택 정렬 : 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꿔야 함
#       3. 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있음
#          -> 따라서 특정 데이터가 삽입될 위치를 찾기 위해 왼쪽으로 1칸씩 이동할 때, 삽입될 데이터보다 작은 데이터를 만나면 그 위치에 삽입되고 멈추면 됨
# 시간 복잡도(= O(N^2)) : (중요) 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작 (최선의 경우 시간 복잡도 = O(N))
# 효율성 : 퀵 정렬과 같은 다른 정렬 알고리즘들과 비교했을 때 "보통은 삽입 정렬이 비효율적"이지만, "정렬이 거의 되어 있는 상황"에서는 퀵 정렬과 같은 다른 알고리즘보다 더 강력함

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1):          # i부터 1까지 감소
        if array[j] < array[j - 1]:    # 1칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else:      # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break

print(array)